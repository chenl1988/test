# 执行上下文：是当前代码执行的一个环境与作用域
  - 程序启动时，从全局执行上下文中开始。一些变量是在全局执行上下文中声明的，为全局变量

## 执行上下文包含三个部分：
  - 变量对象（VO）
  - 作用域链（词法作用域）
  - this指向

### 变量对象：
  - 可以抽象为一种数据作用域，它存储着该执行上下文中的**所有变量和函数声明（不包含函数表达式）**

### 作用域
  - 执行上下文中还包含作用域链
  - 作用域其实可以理解为该上下文中声明的变量和声明的作用范围。可以分为块级作用域和函数作用域
  - 特性：
    - **声明提前**：一个声明在函数体内都是可见的，函数优先于变量
    - 非匿名自执行函数，函数变量为**只读**状态，无法修改
    ```
    let foo = function(){console.log(1)};
    (function foo(){
      foo = 10; //由于foo在函数中只为可读，因此赋值无效
      console.log(foo)
    })()
    ```

#### 函数作用域
  ##### 调用一个函数会发生什么？
    - javascript创建一个新的执行上下文，叫作本地执行上下文
    - 这个本地执行上下文将有它自己的一级变量
    - 新的执行上下文被推到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器
    - 当函数遇到return或者函数的}会结束
  ##### 当一个函数结束时，会发生以下情况
    - 这个本地执行上下文从执行堆栈中弹出
    - 函数将返回值返回调用上下文。调用上下文是调用这个本地执行上下文的，它可以是全局执行上下文，也可以是另外一个本地执行上下文。这取决于调用执行上下文来处理此时的返回值，如果没有return语句，则返回undefined
    - 这个本地执行上下文被**销毁**，销毁是很重要的，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么执行上下文中自有的变量
  
  ##### 函数执行所生成的本地执行上下文，在函数执行完成后，函数的返回值的处理方式上的不同可以产生闭包，闭包对上一级的变量的引用导致函数本地执行上下文没有被销毁




### 作用域链
  - 可以理解为一组对象列表，包含父级和自身的变量对象，因此我们便能通过作用域链访问父级里声明的变量或者函数
  - 由两部分组成：
    - [[scope]]属性：指向低级变量对象和作用域链，也就是包含了父级的[[scope]]t AO
    - AO：自身活动对象