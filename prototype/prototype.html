<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    /* 
      prototype:
      1、prototype是个显示的原型属性
      2、每个函数创建的时候都会默认创建一个prototype属性
      3、function 只是语法糖，实际上还是使用new function();
      4、prototype属性的值是一个对象，对象只有一个constructor属性 构造函数
      5、constructor的作用是让函数的实例知道是哪个构造函数创建了它

      __proto__:
      1、__proto__是隐式的原型属性
      2、每个实例对象都有__proto__属性
      3、__proto__指明了创建实例对象的构造函数的原型
      4、每个实例都是使用new操作符创建的
      5、在使用new操作符时会做以下四件事：
        ·创建一个新对象
        ·为新对象连接原型
        ·为新对象指明this
        ·返回新对角
      6、__proto__实际上指向的是内部属性[[prototype]]，而内部属性无法直接访问
      7、js中没有类的概念，通过__proto__将实例对象与原型连接在一起，组成原型链

     */
  </style>
</head>

<body>


</body>

<script>
  /* prototype只有函数才有这个属性 */
  /* prototype:这是一个显示原型属性，只有函数才拥有该属性，基本上所有函数都有这个属性，但是有一个例外 */

  /*
     1、prototype是一个显示的原型属性
     2、只有函数才有prototype属性，而且是在函数声明时自动创建的
     3、prototype属性值是一个对象，对象只有一个属性constructor构造函数，
     4、constructor的作用是可以让函数的实例对象知道是什么函数构造了它
   */

  let fun = Function.prototype.bind();

  /* 通过上面的方法创建的fun函数是不具有prototype属性的 */

  /* 
    prototype是在函数声明的时候被自动创建的，并且prototype的值是一个对象（也就是原型），只有一个属性constructor
    constructor对应着构建函数，也就是Foo
   */
  function Foo() {}

  /* 
    constructor 是一个公有且不可枚举的属性。一旦改变了函数的prototype，那么新对象就没有这个属性了

    constructor大概有两个作用：
      ·让实例对象知道是什么函数构造了它
      ·如果想给某些类库中的构造函数增加一些自定义的方法，可以通过xx.constructor.method来扩展
   */
</script>

</html>